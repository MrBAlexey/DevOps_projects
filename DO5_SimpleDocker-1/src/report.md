# Simple Docker

Введение в докер. Разработка простого докер-образа для собственного сервера.


## Contents

0. [Chapter III](#chapter-iii) \
1. [Готовый докер](#part-1-готовый-докер) \
2. [Операции с контейнером](#part-2-операции-с-контейнером) \
3. [Мини веб-сервер](#part-3-мини-веб-сервер) \
4. [Свой докер](#part-4-свой-докер) \
5. [Dockle](#part-5-dockle) \
6. [Базовый Docker Compose](#part-6-базовый-docker-compose)



## Chapter III

В качестве результата работы по первым двум задачам должен быть предоставлен отчет.
В каждой части задания указано, что должно быть помещено в отчёт, после её выполнения.
Это могут быть ответы на вопросы, скриншоты и т.д.

В качестве результата работы по третьей задаче должны быть предоставлены исходные файлы для запуска веб-сервера.

В качестве результата работы по четвёртой и пятой задачам должны быть предоставлены докерфайлы.

В качестве результата работы по шестой задаче должен быть предоставлен файл *docker-compose.yml* и нужные для его запуска докерфайлы (если они не были предоставлены ранее).

- В репозиторий, в папку src, должен быть загружен отчёт с расширением .md;
- В отчёте должны быть выделены все части задания, как заголовки 2-го уровня;
- В рамках одной части задания всё, что помещается в отчёт, должно быть оформлено в виде списка;
- Каждый скриншот в отчёте должен быть кратко подписан (что показано на скриншоте);
- Все скриншоты обрезаны так, чтобы была видна только нужная часть экрана;
- На одном скриншоте допускается отображение сразу нескольких пунктов задания, но они все должны быть описаны в подписи к скриншоту;
- В репозиторий, в папку src/server, должны быть загружены исходные файлы для запуска веб-сервера из третьего задания;
- В репозиторий, в папку src, должны быть загружены итоговые докерфайлы для запуска образов из четвёртого и пятого заданий;
- В репозиторий, в папку src, должен быть загружен *docker-compose.yml* шестого задания;
- Необходимо быть готовым продемонстрировать решение вживую при необходимости.

## Part 1. Готовый докер

В качестве конечной цели своей небольшой практики ты сразу выбрал написание докер-образа для собственного веб-сервера, а потому в начале тебе нужно разобраться с уже готовым докер-образом для сервера.
Твой выбор пал на довольно простой **nginx**.

**== Задание ==**

##### Возьми официальный докер-образ с **nginx** и выкачай его при помощи `docker pull`.

![](screenshots/1.1.1(docker_pull_nginx).png)

##### Проверь наличие докер-образа через `docker images`.

![](screenshots/1.2.2(docker_images).png)

##### Запусти докер-образ через `docker run -d [image_id|repository]`.
3. `запустим docker командой: docker run -d e784f4560448`

![](screenshots/1.3.3(docker_run).png)

 >-d: это флаг, указывающий на запуск контейнера в фоновом режиме (detached mode). Это означает, что контейнер будет работать в фоновом режиме, и командная строка будет освобождена для дальнейшего использования.

##### Проверь, что образ запустился через `docker ps`.
4. `посмотрим запущенные контейнеры`

![](screenshots/1.4.4(docker_ps).png)

> команда docker ps выводит только запущенные контейнеры. При запуске команды docker ps без дополнительных флагов будут отображены только запущенные контейнеры в текущий момент времени.
> ps -a выведет и остановленные контейнеры. 

##### Посмотри информацию о контейнере через `docker inspect [container_id|container_name]`.
5. `узнаем информацию о контейнере с помощью команды:`
>`docker inspect frosty_fermat`

![](screenshots/1.5.5(docker_inspect).png)


##### По выводу команды определи и помести в отчёт размер контейнера, список замапленных портов и ip контейнера.
6. `выведем размер контейнера:`
>`docker inspect frosty_fermat --size | grep -i -e Size`

![](screenshots/1.6.6(docker_size).png)

6.1. `выведем список замапленных портов:` 
  
![](screenshots/1.6.7(docker_ports).png)

  6.2. `выведем ip контейнер командой:`

  ![](screenshots/1.6.8(docker_ip).png)


##### Останови докер образ через `docker stop [container_id|container_name]`.
##### Проверь, что образ остановился через `docker ps`.
7. `остановим контейне командой:`
>`docker stop frosty_fermat`

8. `проверим остановк командой:`
>`docker ps`

![](screenshots/1.7_8.9(docker_stop_and_ps).png)

##### Запусти докер с портами 80 и 443 в контейнере, замапленными на такие же порты на локальной машине, через команду *run*.
9. `запустим докер через с порты 80 и 443 командой:`
>`docker run -d -p 80:80 -p 443:433 nginx`

где флаг -p - порт

-d    - daemon работа в фоновом режиме 

![](screenshots/1.9.10(docker_start_with_ports_80_443).png)

##### Проверь, что в браузере по адресу *localhost:80* доступна стартовая страница **nginx**.
10. `проверим в браузере по адресу localhost:80 доступ к стартовой странице nginx:`

![](screenshots/1.10.11(docker_start_with_ports_80_443).png)

##### Перезапусти докер контейнер через `docker restart [container_id|container_name]`.
11. `перезапусти командой docker restart frosty_fermat и проверил запуск docker ps:`
  ![](screenshots/1.11.12(docker_restart).png)

##### Проверь любым способом, что контейнер запустился.
12. `посмотрим запущенные контейнер командой:` 
>`docker ps`
  ![](screenshots/1.12.13(docker_ps).png)


## Part 2. Операции с контейнером

##### Прочитай конфигурационный файл *nginx.conf* внутри докер контейнера через команду *exec*.
1. `прочитаем конфигурационный файл *nginx.conf командой:`
  >`docker exec silly_solomon cat /etc/nginx/nginx.conf `

![](screenshots/2.1.14(docker_configuration).png)

##### Создай на локальной машине файл *nginx.conf*.
2. `создадим локальный файл nginx.conf командой:`
>`touch nginx.conf`

![](screenshots/2.2.15(docker_touch_nginx.config).png) 

##### Настрой в нем по пути */status* отдачу страницы статуса сервера **nginx**.
3. `настроим по пути /status отдачу страницы статуса сервера`

![](screenshots/2.3.16(docker_return_page).png)

##### Скопируй созданный файл *nginx.conf* внутрь докер-образа через команду `docker cp`.
4. `скопируем созданный файл внутрь докер-образа командой:`
>`docker cp nginx.conf silly_solomon:/etc/nginx`

![](screenshots/2.4.17(docker_cp_nginx.conf).png)

##### Перезапусти **nginx** внутри докер-образа через команду *exec*.
5. `Перезапустим ngin командой:` 
>`docker exec silly_solomon nginx - s reload`

![](screenshots/2.5.18(docker_nginx_restart).png)

##### Проверь, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.
6. `проверим адрес localhost:80/status командой:`
>`docker exec silly_solomon curl localhost:80/status`

![](screenshots/2.6.19(docker_check_80_status).png)

![](screenshots/2.6.20(browser_check_80_status).png)

##### Экспортируй контейнер в файл *container.tar* через команду *export*.
##### Останови контейнер.
7. `экспортируем в файл, остановим контенер и проверим остановку командами:`
>`docker export silly_solomon > container.tar`

8. >`docker stop silly_solomon`
>`docker ps`

![](screenshots/2.7_8.21(docker_export_to_file_container.tar).png)

##### Удали образ через `docker rmi [image_id|repository]`, не удаляя перед этим контейнеры.
9. `удалим образ командой:` 
>`docker rmi -f nginx`

-f - опция "force", которая принудительно удаляет образ, даже если он используется запущенными контейнерами

![](screenshots/2.9.22(docker_delete_image).png)

##### Удали остановленный контейнер.
10. `удалим остановленный контейнер командой:`
>`docker rm frosty_fermat`

![](screenshots/2.10.23(docker_delete_image).png)

##### Импортируй контейнер обратно через команду *import*.
11. `импортируем контейнер обратно командой:`
>`docker import -c 'CMD ["nginx", "-g", "daemon off;"]' -c 'ENTRYPOINT ["/docker-entrypoint.sh"]' container.tar nginx`

опция -c используется для задания команды запуска образа при его выполнении. В данном случае, задана команда CMD ["nginx", "-g", "daemon off;"], которая запустит контейнер с использованием Nginx и опцией -g для указания глобальных директив Nginx. Фраза daemon off; отключает режим демона Nginx, позволяя процессу остаться в переднем плане, а не перейти в фоновый режим.

-c 'ENTRYPOINT ["/docker-entrypoint.sh"]': опция -c также используется для задания точки входа (entrypoint) образа.

![](screenshots/2.11.24(docker_import_container_from_file).png)

##### Запусти импортированный контейнер.
12. запустим импортированный контейнер командой:
>`docker run -d -p 80:80 -p 443:433 a35ed18bb7fc0fb2`

![](screenshots/2.12.25(docker_start).png)

##### Проверь, что по адресу *localhost:80/status* отдается страничка со статусом сервера **nginx**.
13. проверим отдачу страницы со статусом сервера nginx
![](screenshots/2.13.26(browser_localhost_status).png)

- В отчёт помести скрины:
  - вызова и вывода всех использованных в этой части задания команд;
  - содержимое созданного файла *nginx.conf*;
  - страницы со статусом сервера **nginx** по адресу *localhost:80/status*.

## Part 3. Мини веб-сервер

Теперь стоит немного оторваться от докера, чтобы подготовиться к последнему этапу. Время написать свой сервер.

**== Задание ==**

##### Напиши мини-сервер на **C** и **FastCgi**, который будет возвращать простейшую страничку с надписью `Hello World!`.
1. `написал мини сервер на языке Си и FastCGI`

`функция FCGI_Accept() принимает FastCGI-запрос и возвращает значение, указывающее успешность его выполнения. При успешном выполнении запроса выполняется блок кода внутри цикла.`

`внутри цикла выводится HTTP-заголовок, указывающий, что содержимое является текстом HTML (Content-type: text/html) и статус ответа (Status: 200 OK). Затем выводится сам контент ответа (Hello World!).`

![](screenshots/3.1.27(docker_server_hello_world).png)

##### Запусти написанный мини-сервер через *spawn-fcgi* на порту 8080.

2. запустим контейнер с образом Nginx и привязал порт 81 на хостовой машине к порту 81 внутри контейнера командой:
>`docker run -d -p 81:81 nginx`. 

>-d - опция "detach", которая запускает контейнер в фоновом режиме
>-p 81:81 - опция "publish", которая привязывает порт 81 на хостовой машине к порту 81 в контейнере apt

- далее скопируем созданный файл nginx.conf и мини-сервер в докер контейнер командой:
>`docker cp nginx.conf pedantic_dirac:/etc/nginx/`
>`docker cp server_prt_3.c pedantic_dirac:/home` 

- зайдём в его терминал: 
  >`docker exec -it pedantic_dirac bash`

![](screenshots/3.2_3.28(docker_server_copy).png)

- установим необходимое ПО командами: 

> `apt-get update` 

> `apt-get install -y gcc spawn-fcgi libfcgi-dev`

spawn-fcgi - пакет, содержащий инструмент для запуска FastCGI-программ

libfcgi-dev - пакет, содержащий заголовочные файлы и библиотеку FastCGI для разработки

-y - c данной опцией на все вопросы автоматически предоставляется ответ Yes. Это полезно при автоматической установке пакетов в скриптах или в среде контейнеров, где интерактивное взаимодействие с пользователем невозможно.

spawn-fcgi используется для запуска удаленных и локальных FastCGI процессов.

![](screenshots/3.2_3.29(docker_apt_update_install_gcc_fcgi).png)


- скомпилируем, запустим мини-сервер через spawn-fcgi на порту 8080 и перезагрузим nginx командами:

>`gcc -o server server_prt_3.c -lfcgi`

>`spawn-fcgi -p 8080 ./server`

>`nginx -s reload`

-lfcgi - опция "link", указывает, что программа должна быть связана с библиотекой libfcgi

![](screenshots/3.2_3.30(docker_gcc_server_start_reload).png)

##### Напиши свой *nginx.conf*, который будет проксировать все запросы с 81 порта на *127.0.0.1:8080*.
3. напишем свой nginx.conf

![](screenshots/3.3.31(docker_nginx_conf_create).png)

##### Проверь, что в браузере по *localhost:81* отдается написанная тобой страничка.
4. перейдём в браузере по адрессу localhost:81
![](screenshots/3.4.32(check_server_hello_world).png)

##### Положи файл *nginx.conf* по пути *./nginx/nginx.conf* (это понадобится позже).
5. скопируем конфигурационный файл nginx в наш контейнер, командой:
> `docker cp nginx.conf pedantic_dirac:/etc/nginx/nginx.conf`      

![](screenshots/3.5.33(docker_nginx_copy).png)

## Part 4. Свой докер

Теперь всё готово. Можно приступать к написанию докер-образа для созданного сервера.

**== Задание ==**

*При написании докер-образа избегай множественных вызовов команд RUN*

#### Напиши свой докер-образ, который:
##### 1) собирает исходники мини сервера на FastCgi из [Части 3](#part-3-мини-веб-сервер);

##### 2) запускает его на 8080 порту;
##### 3) копирует внутрь образа написанный *./nginx/nginx.conf*;
##### 4) запускает **nginx**.
_**nginx** можно установить внутрь докера самостоятельно, а можно воспользоваться готовым образом с **nginx**'ом, как базовым.
1. создадим файл с названием Dockerfile в папке src/part_4 и напишем в нём докер образ 

> FROM задает образ, чья файловая система берется за основу.

> WORKDIR задает рабочий каталог, относительно которого выполняются все действия во время формирования образа и при входе в контейнер.

> ADD добавляет файлы/папки из текущего окружения в образ. Если в качестве копируемого файла указать архив, то он будет добавлен в образ в распакованном виде. Также в качестве источника принимает URL.

> COPY копирует файлы и директории с хост-машины внутрь Docker-образа.

> RUN выполняет переданную строчку в терминале от пользователя root. С ее помощью вносятся основные изменения в файловую систему, добавляются пакеты, ставятся зависимости и так далее.

> CMD задает команду, которая выполняется при запуске контейнера по умолчанию. Она используется только в том случае, если контейнер был запущен без указания команды. Используется CMD
docker run -it hexlet/docker-fastify-example # npm start

> CMD не используется, так как явно указан bash
docker run -it hexlet/docker-fastify-example bash

> ENTRYPOINT указывает команду, которой будет передаваться параметр при запуске контейнера.

> EXPOSE Указывает, какой порт должно использовать приложение внутри контейнера.

> /bin/bash запускает интерактивный режим командной оболочки Bash. 

![](screenshots/4.1.34(docker_dockerfile_add).png)
![](screenshots/4.1.35(docker_run.sh_add).png)
##### Собери написанный докер-образ через `docker build` при этом указав имя и тег.
2. `соберём докер образ командой:`
> `docker build . -t test_jhadxaro:1.0`

![](screenshots/4.2.36(docker_build).png)

##### Проверь через `docker images`, что все собралось корректно.
3. `проверим сборку командой:`
>`docker images`
![](screenshots/4.3.37(docker_check_images).png)

##### Запусти собранный докер-образ с маппингом 81 порта на 80 на локальной машине и маппингом папки *./nginx* внутрь контейнера по адресу, где лежат конфигурационные файлы **nginx**'а (см. [Часть 2](#part-2-операции-с-контейнером)).
4. `запустим собранный докер-образ с маппингом 81 порта на 80 на локальной машине и маппингом папки командой:`
>`docker run -d -p 80:81 -v /Users/jhadxaro/Documents/Projects/Linux/DO5_SimpleDocker-1/src/part_4/nginx.conf:/etc/nginx/nginx.conf test_jhadxaro:1.0 bash`

> -p 80:81 - маппинг портов. Порт 80 на локальной машине будет проксироваться на порт 81 внутри контейнера.

> -v в команде Docker используется для создания маппинга томов (volumes). Он позволяет связывать директории или файлы на вашем хосте с директориями внутри контейнера.

> -d: Запускает контейнер в фоновом режиме (daemon mode).

![](screenshots/4.4.38(docker_run).png)

##### Проверь, что по localhost:80 доступна страничка написанного мини сервера.
5. убедимся в доступности странички мини сервера по адресу localhost:80 командой:

>`curl localhost:80`

![](screenshots/4.5.39(docker_check_localhost).png)

##### Допиши в *./nginx/nginx.conf* проксирование странички */status*, по которой надо отдавать статус сервера **nginx**.
6. `допишем проксирование странички:`
 
![](screenshots/4.6.40(docker_add_stub_status).png)

##### Перезапусти докер-образ.
*Если всё сделано верно, то, после сохранения файла и перезапуска контейнера, конфигурационный файл внутри докер-образа должен обновиться самостоятельно без лишних действий*
7. `перезагрузим наш контейнер командой:`
> `docker restart lucid_kapitsa `   

![](screenshots/4.7.41(docker_restart_container).png)

##### Проверь, что теперь по *localhost:80/status* отдается страничка со статусом **nginx**
8. теперь по *localhost:80/status* отдается страничка со статусом **nginx*

![](screenshots/4.8.42(docker_check_localhost_status).png)



## Part 5. **Dockle**

##### Просканируй образ из предыдущего задания через `dockle [image_id|repository]`.
##### Исправь образ так, чтобы при проверке через **dockle** не было ошибок и предупреждений.


- установим утилиту dockly командой:
>`brew install goodwithtech/r/dockle`

1. скопируем папку с 4го задания

2. соберём образ командой: 
>`docker build . -t test_jhadxaro:2.0 ` 

3. просканируем образ test_jhadxaro:2.0 на ошибки командой:
>`dockle test_jhadxaro:2.0`

4. для исправления ошибок отредактируем Dokerfile 

5. соберём образ и запустим проверку командами:
>`docker build . -t test_jhadxaro:2.0`
>`dockle -ak NGINX_GPGKEY -ak NGINX_GPGKEY_PATH test_jhadxaro:2.0`
![](screenshots/5.1.43(docker_build_image).png)
![](screenshots/5.2.44(dockly_check_image).png)

## Part 6. Базовый **Docker Compose**

##### Напиши файл *docker-compose.yml*, с помощью которого:
##### 1) Подними докер-контейнер из [Части 5](#part-5-инструмент-dockle) _(он должен работать в локальной сети, т.е. не нужно использовать инструкцию **EXPOSE** и мапить порты на локальную машину)_.
##### 2) Подними докер-контейнер с **nginx**, который будет проксировать все запросы с 8080 порта на 81 порт первого контейнера.
1. поднимем докер-контейнер с nginx

![](screenshots/6.1.45(docker_nginx_conf).png)

2. 
>`docker run -d 1ed60a65731d`

![](screenshots/6.1.46(docker_start_container).png)

##### Замапь 8080 порт второго контейнера на 80 порт локальной машины.
3. замапим 8080 порт второго контейнера на 80 порт локальной машины.

![](screenshots/6.2.47(docker_compose_yml).png)

##### Останови все запущенные контейнеры.
3. остановим все запущенные контейнеры командой:
> `docker stop admiring_snyder`

![](screenshots/6.3.48(docker_stop_container).png)

##### Собери и запусти проект с помощью команд `docker-compose build` и `docker-compose up`.
4. соберём и запустим проект с помощью команд:
> `docker-compose build` 
> `docker-compose up -d`

> флаг -d означает "в фоновом режиме" (detached mode), что позволяет вам запустить контейнеры в фоне, без блокировки вашего терминала.

> chown -R nginx:nginx /etc/nginx/nginx.conf; Эта команда изменяет владельца и группу файла конфигурации Nginx на nginx, чтобы пользователь nginx имел право на его чтение и запись.

![](screenshots/6.4.49(docker_compose_build_up).png)

##### Проверь, что в браузере по *localhost:80* отдается написанная тобой страничка, как и ранее.

![](screenshots/6.5.50(browser_localhost_80_check).png)
